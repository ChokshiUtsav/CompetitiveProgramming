<html>
<title> C++ Tricks and Tips </title>
<body>
<h1><b> Few C++ Tricks and Tips </b></h1>
<h2><u> Important I/O Techniques </u></h2>

<h3>How to scan two integers infinitely? </h3>
<pre><code>
<em style="color:blue;">
while(scanf("%d %d\n",&m,&n)==2)
{
	cout << m << n << endl; 
}
</em></code></pre>

<h3>How to scan a line infinitely? </h3>
<pre><code>
<em style="color:blue;">
string input_line;
while(getline(cin,input_line))
{
	cout << input_line << endl; 
}
</em></code></pre>

<h3>How to scan a string and unknown number of integers on a single line infinitely? </h3>
<pre><code>
<em style="color:blue;">
#include &lt;sstream&gt;
string input_line;
string first_string;
vector&lt;int&gt; vec;
int i;
while(getline(cin,input_line))
{
	stringstream ss(input_line);
	ss >> first_string;

	while(ss >> i){
		vec.push_back(i);
	}
	vec.clear();
}

<u>Sample Input :</u> 
Utsav 1 2 3
Chokshi 1 7 8
</em></code></pre>

<h3>How to perform string formatting for I/O? </h3>
<pre><code>
<em style="color:blue;">
#include &lt;iomanip&gt;
//Setting alignment and word length
cout << setw(20) << left << "HEADER" << endl;

//Filling empty space with some character
cout << setfill('-') << setw(20) << left << "HEADER" << endl;
</em></code></pre>

<h3>How to perform float/double formatting for I/O? </h3>
<pre><code>
<em style="color:blue;">
#include &lt;iomanip&gt;
float pi = 3.1456;
//Setting precision upto 2 decimal points
cout << fixed;
cout << setprecision(2) << pi << endl;

</em></code></pre>

<h3>Defining multidim array (statically and dynamically) and initializing it</h3>
<pre><code>
<em style="color:blue;">

bool mat[9][9][9];
memset(mat,false,sizeof(mat));

int n = 9;
bool *mat[n];
for(int i=0; i&lt;n; i++){
	mat[i] = (int*)malloc(n*sizeof(int));
}
memset(mat,false,sizeof(mat));

</em></code></pre>


<h2><u> Important String functions and Techniques </u></h2>

<h3> Iterating over characters of 'string' datatype? </h3>
<pre><code>
<em style="color:green;">
string sample_string = "utsav";
int length = sample_string.size();
for(int index=0; index &lt; length; index++){
	cout << sample_string[index] << endl;
}
</em></code></pre>

<h3> Sorting a string and Reveresal of a string </h3>
<pre><code>
<em style="color:green;">
string sample_string = "utsav";

//It is similar to vector : inplace sorting
sort(string.begin(),string.end());
sort(string.begin(),string.begin()+2);

//Inplace reverse
reverse(sample_string.begin(),sample_string.end())
</em></code></pre>

<h3> Checking a type of character </h3>
<pre><code>
<em style="color:green;">
string str = "utsav";

isdigit(str[0])
isalpha(str[0])
isalnum(str[0])
ispunct(str[0])
isspace(str[0])
islower(str[0])
isupper(str[0])

</em></code></pre>

<h3> Converting string to integer and vice-versa </h3>
<pre><code>
<em style="color:green;">
#include &lt;cstdlib&gt; //for atoi
#include &lt;sstream&gt; //for stringstream

//converting string to integer
string str = "124";
int i = atoi(str.c_str());

//converting integer to string
int i = 42;
stringstream ss;
ss << i;
string s = ss.str();

</em></code></pre>

<h3> Finding next/previous permutation of string  </h3>
<pre><code>
<em style="color:green;">
#include &lt;string&gt;

string str= "abcd";

bool flag = next_permutation(str.begin(),str.end());

//True : next lexicographically larger permutation exists and replaces str with it.
//False : current string is last permutation.
if(flag){
	cout << "Next Perm :" << str << endl;
}
else{
	cout << "Last permutation of string reached." << endl;
}

//Previous lexicograhically smaller perm
flag = prev_permutation(str.begin(),str.end());

</em></code></pre>

<h3> String comparision </h3>
<pre><code>
<em style="color:green;">
#include &lt;string&gt;

string str1 = "abc";
string str2 = "abcd";
string str3 = "abd";
string str4 = "abc";
string str5 = "aba";

int i = str1.compare(str2); // str1 < str2 -> returns some val < 0 (-1)
i = str1.compare(str3); // str1 < str3 -> returns some val < 0 (-1)
i = str1.compare(str4); // str1 = str4 -> returns 0
i = str1.compare(str5); // str1 > str5 -> return some val > 0 (2)

</em></code></pre>

<h3> SubString and Find and Replace</h3>
<pre><code>
<em style="color:green;">
#include &lt;string&gt;

string fullname = "a12utsav chokshi"
string name = fullname.substr(2,5);    //substr(start_index,length)

size_t found = fullname.find("a");	   // substring to be found can be string or character
size_t found = fullname.find('a');

if(found != nopos){
	cout << "Pos :" << found << endl;
}

found = fullname.find("a",found+3,5);  //similar to finding a in utsav

fullname.replace(found,1,"hello");  //a12utsav chokshi -> a12utshellov chokshi

</em></code></pre>

<h2><u> Important Vector functions and Techniques </u></h2>

<h3> Sorting vector of struct instances </h3>

<pre><code>
<em style="color:blue;">
struct Point{
	float x1;
	float y1;
}

bool pointComp(const Point& lhs, const point& rhs){
	// for sorting in ascending order
	return lhs.x1 < rhs.x1;
}

vector<Point> pointVec;

sort(pointVec.begin(),pointVec.end(),pointComp);
sort(pointVec.begin(),pointVec.begin()+5; pointComp);

</em></code></pre>

<h3> Other important functions </h3>
<pre><code>
<em style="color:blue;">

vector&lt;int&gt; vec;

//getting length of vector
int length = vec.size();

//clearing content of vector
vec.clear();

//defining intial size of vector
vec.reserve(100);

//getting capacity of vector
vec.capacity();

//inserting elemets to vector
vec.push_back(5);

//accessing elements of vector
int temp = vec[0];	

//intializing vector with some value
vector&lt;float&gt; vec2(10,0.0);

//removing nth element from vector
int n = 3;
vec.erase(vec.begin()+n);

//swaping two elements
swap(vec[0],vec[1]);

</em></code></pre>

<h2><u> Important Map functions and Techniques </u></h2>
<p><i><ul>
<li>Maps in C++ are implemented using Red-Black Tree.</li>
<li>So it takes O(logn) time for insertion/deletion/search.</li>
<li>So it is better than array of pairs [O(n)] but worse than hash tables [O(1)].</li>
<li>To use unordered_map : just replace map with unordered_map.</li>
<li>unordered_map is feature of C++11 and it is implemented using hashing. Hence provides O(1) complexity for access.</li>

</ul></i></p>

<h3> Defining and accessing map </h3>

<pre><code>
<em style="color:green;">
#include &lt;map&gt;

map&lt;string,int&gt; m1;
m1['utsav'] = 1;

</em></code></pre>

<h3> Checking for key existence and iterating over keys in map </h3>

<pre><code>
<em style="color:green;">
#include &lt;map&gt;

map&lt;string,int&gt; m1;
m1["utsav"] = 1;


//Iterating over all keys
map&lt;string,int&gt;::iterator it;
vector&lt;string&gt; vec;

for(it=m1.begin(); it!=m1.end(); it++){
	vec.push_back(it->first);
}

//Checking for key
string key = "utsav";
if(m1.find("utsav") == m1.end()){
	cout << "Key not found." << endl;
}

</em></code></pre>

<h2><u> Important Stack functions and Techniques </u></h2>

<h3> Defining and accessing stack </h3>
<pre><code>
<em style="color:blue;">
#include &lt;stack&gt;

stack&lt;int&gt; s;

s.push(3);
int temp = s.top();
s.pop();        //returns nothing

bool flag = s.empty();
int  length = s.size();
</em></code></pre>

<h3> There is no such thing as iterator for stack. So don't try ! :)</h3>

<h2><u> Important Queue functions and Techniques </u></h2>

<h3> Defining and accessing queue </h3>
<pre><code>
<em style="color:green;">
#include &lt;queue&gt;

queue&lt;int&gt; q;

q.push(3);			//Inserts element at the end.
q.pop();			//Returns nothing and deletes element from the front.

int f = q.front();  //First element in queue
int b = q.back();   //Last element in queue

int length = q.size();
bool flag = q.empty();

</em></code></pre>

<h3> There is no such thing as iterator for queue. So don't try ! :)</h3>

<h2><u> Important Set functions and Techniques </u></h2>

<h3> Defining and accessing set </h3>
<p><i><ul>
<li>Sets in C++ are containers that stores only unique elements.</li>
</ul></i></p>

<pre><code>
<em style="color:blue;">
#include &lt;set&gt;

set&lt;int&gt; s;

s.insert(3);        //Inserts element into the set.
s.erase(3);         //Deletes element from set.

int length = s.size();
bool flag = s.empty();

//clearing content
s.clear();

</em></code></pre>

<h3> Finding element and iterating over all elements in set </h3>

<pre><code>
<em style="color:blue;">
#include &lt;set&gt;

set&lt;int&gt; s;
s.insert(2);

if(s.find(2) != s.end()){
	cout << "Found" << endl;
}
else{
	cout << "Not Found" << endl;	
}

set&lt;int&gt;::iterator it;
for(it=s.begin(); it!=s.end(); it++){
	cout << *it << endl;
}

</em></code></pre>

<h2><u> How to use Pair ? </u></h2>

<h3> Defining and accessing pair structure </h3>
<pre><code>
<em style="color:green;">
#include &lt;utility&gt;

pair&lt;int,int&gt; p1;
p1 = make_pair(10,20);

cout << p1.first << " " << p1.second << endl;
</em></code></pre>

</body>
</html>